# 先看看依赖的概念

依赖，描述的是一个类和另一个类之间的关系。



# 关于依赖倒置

软件开发六大原则中的之一。这六大原则的目的，都是为了实现软件代码的低耦合，高内聚。

- (S)单一职责原则：一个类仅负责一件事。降低类的复杂性。但是这个并不是绝对的。
- (L)里氏替换原则：也就是面向接口编程，能够使用接口定义变量，绝对不要用实现类。
- (D)依赖倒置原则：高层模块不应该依赖低层模块。让模块和模块之间利用接口解耦，彼此独立。
- (I)接口隔离原则：接口的方法应该尽量少，不要尝试去建立一个庞大的接口包揽全局。
- (L)迪米特法则：一个类它对自己依赖的其他类，知道的越少越好，因此也叫做最少知道原则。
- (O)开闭原则：一个类，应该要尽量对修改封闭，对扩展开放。

`solidl` 6大原则

# 再看依赖注入

不去使用依赖注入的时候

```java
class A {
	B b;
	C c;
	public void doSth(){
		b = B();
         c = C();
         b.doSth();
         c.doSth();
	}
}
```

使用了依赖注入之后：

```java
class A {
	B b;
	C c;
    public A(B b,C c){
        this.b = b;
        this.c = c;
    }
	public void doSth(){
		if(b!=null)
            b.doSth()
         if(c!=null)
            c.doSth()
	}
}
```

这里的ABC类，A要使用到BC，相对而言，A就是BC的高层，BC是A的低层，依赖倒置原则，高层模块不应该依赖低层模块。所以，A类里面不要去new B和C。而是要向下面这样，从外界传入。通过构造函数传入，通过set方法传入，或者通过接口实现的形式注入，或者通过注解解析的方式传入。总之，没有传入的时候和传入的时候A类的代码都一样，只是做的事情不同而已。

# 著名的依赖注入库

`Dagger2`











